<html>
<head>
  <title>A Leaflet map!</title>
  <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.css"/>
  <script src="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.js"></script>
  <script src="data/jquery-2.1.1.min.js"></script> 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.8.9/jquery.csv.min.js"></script>
    
  <style>
    #map{ width: 900px; height: 500px; }
  </style>
</head>
<body>

<svg width="960" height="500"></svg>
  
  <script>
  var modelData = [];
  // sets up the lats and lons for finding the closest model point
  var lats = [40.81048, 40.78696, 40.76345, 40.73993, 40.71642, 40.69291, 40.66939, 40.64588, 40.62236, 40.59885], 
      lons = [-111.713403, -111.7325994, -111.7517958, -111.7709922, -111.7901886, -111.809385, -111.8285814, -111.8477778, -111.8669742, -111.8861706, -111.905367, -111.9245634, -111.9437598, -111.9629562, -111.9821526, -112.001349],
      times = [],
      timesNumeric = [];
      
     //sets up the times to find closest time point on model
    let hour = 7;
    for(var day = 1; day < 14; day++){
        while(hour < 24){
          let date = new Date(2018, 02, day, hour, 0)
          timesNumeric.push(Date.parse(date + "MST"));
          times.push(date);
          if(day == 13 && hour == 7){
              break;
          }
          hour++;
        }
        hour = 0;
    }  
    
  var processedData;
  //grabs the JSON data
  $.getJSON("data/AllSensorData.json",function(data){
      $.getJSON("data/stacked.json",function(stackedData){
            //runs the signal detection code on the data
            processedData = performSignalDetection(data);
            
            
            var spikes = [];
            var modelPts = [];
            
            processedData.forEach(function(monitor){ // for each air quality monitor 
                if(isEmpty(monitor.signalDetection)|| !monitor.signalDetection){ //if it doesn't have any recordings, skip
                    return;
                }
                
                // determine the closest point in the model to the sensor
                let closestLat = closest(lats,monitor.coordinates[0]);
                let closestLon = closest(lons,monitor.coordinates[1]);
                let closestTimeIndex;
                
                for (var i = 0; i < monitor.signalDetection.signals.length ; i++) { //for each measurment in the monitor
                    if (monitor.signalDetection.signals[i][1] === 1) { //if the signal value is 1 (ie there is a peak)
                        spikes.push({
                            id: monitor.id,
                            coordinates: monitor.coordinates,
                            closestModel: [closestLat,closestLon],
                            measurements: monitor.values.slice(i+60,i+180),// offset by 120 as the lag offsets the dates/times
                            reading: monitor.signalDetection.signals[i],
                        });
                        
                        // and find the closest time corresponding to that
                        closestTimeIndex = closestIndx(timesNumeric, Date.parse(monitor.values[i+120].date)) // parses the date to a number and and finds the closest value
                        
                        //push that point onto the modelPts array
                        modelPts.push( stackedData.filter(function(point){
                            return point.lat == closestLat &&
                                   point.long == closestLon &&
                                   point.x == closestTimeIndex;
                        }));
                        modelPts[modelPts.length-1].time =  times[closestTimeIndex];
                        // add the time to it Q: Why is it 8 hours different? Is it time zones?
                    }
                }
            })
            
        console.log(spikes[0]);
        console.log(modelPts[0]);
        
       
      });    
   });


function performSignalDetection(data){
    data.forEach(function(monitor){
        if(!monitor.values){
            return;
        }
        let SIG_LAG = 120;
        let SIG_THRESH = 10;
        let SIG_INF = 1;
        //monitor.signalDetection = smoothedZScore(monitor.values,SIG_LAG, SIG_THRESH,SIG_INF);
        monitor.signalDetection = smoothedZScore2(monitor.values,SIG_LAG, SIG_THRESH,SIG_INF);
    })//end data.forEach
    return data;
}//end function performSignalDetection

function smoothedZScore2(data,lag,threshold,influence){
    let y = data;                           // Copy Variable name to 'y' since so much of this was written with 'y'
    let yVals = data.map(function(val){     // extract y values from the {date, value} object
        return val.value;
    });
    if(isEmpty(yVals)){
        return;
    }
    //create signals array
    var signals = [];
    var avgFilter = [];
    var stdFilter = [];

    for(var i = 0; i < y.length; i++){
        signals.push(0);
        avgFilter.push(0);
        stdFilter.push(0);
    }

    var filteredY = yVals.slice(0,lag);


    avgFilter[lag-1] = average(yVals.slice(0,lag));
    stdFilter[lag-1] = stanDeviate(yVals.slice(0,lag));
        console.log("passed first std")
    

    for(var i = lag; i <= y.length-1; i++){  //might need to remove equals

        let date = y[i].date;     //read and save date for this datapoint

        if(Math.abs(yVals[i] - avgFilter[i-1]) > threshold * stdFilter[i-1]){
            //if the MAGNITUDE of the current (measurement-avg) value is above the thresh*std.Dev....

            if(yVals[i] > avgFilter[i-1]){
                //if this value is above average, mark positive signal
                signals[i] = [date,1];
            } else{
                //otherwise we are below average, mark negative signal
                signals[i] = [date,-1];
            }//end if-else y[i]


            filteredY[i] = influence * yVals[i] + (1-influence) * filteredY[i-1];

        } else {
            //if the MAGNITUDE does not exceed our threshold value, there is no signal, mark 0
            signals[i] = [date,0];
            filteredY[i] = yVals[i];
        } //end if-else Math.abs


        var start = i-lag;
        avgFilter[i] = average(filteredY.slice(start,i));
        stdFilter[i] = stanDeviate(filteredY.slice(start,i));

    }//end for i

    //remove the zero entries from 'signals

    let measurementPairs = signals.slice(lag);
    return { signals:measurementPairs, avgFilter:avgFilter, stdFilter:stdFilter};
}//end smoothedZScore2

function average(arr){
    return arr.reduce((a,b) => a + b, 0) / arr.length;
}

function stanDeviate(theData){
    var meanOfOrg = (theData.reduce(function(l,r){return l+r;}))/theData.length;
    var theSqrdSet = theData.map(function(el){ return Math.pow((el - meanOfOrg),2)});
    var theResult = Math.sqrt((theSqrdSet.reduce(function(l,r){return l+r;}))/theSqrdSet.length);
    return theResult;
}

function isEmpty(obj) {
    for(var key in obj) {
        if(obj.hasOwnProperty(key))
            return false;
    }
    return true;
}

function closest(array,num){
    var i=0;
    var minDiff=1000;
    var ans;
    for(i in array){
         var m=Math.abs(num-array[i]);
         if(m<minDiff){ 
                minDiff=m; 
                ans=array[i]; 
            }
      }
    return ans;
}

function closestIndx(array,num){
    var i=0;
    var minDiff= 9007199254740990;
    var minIndex;
    for(i in array){
         var m=Math.abs(num-array[i]);
         if(m<minDiff){ 
                minDiff=m; 
                minIndex = i; 
            }
      }
    return minIndex;
}
  </script>
</body>
</html>

